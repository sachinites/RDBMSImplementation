#include <string.h>
#include <list>
#include "sql_delete.h"
#include "Catalog.h"
#include "../BPlusTreeLib/BPlusTree.h"
#include "rdbms_struct.h"
#include "SqlMexprIntf.h"
#include "qep.h"
#include "sql_join.h"

extern BPlusTree_t TableCatalogDef;

void
sql_drop_table (char *table_name) {

    BPluskey_t bkey;
    catalog_table_key_t catalog_table_key;

    if (!sql_catalog_table_lookup_by_table_name (&TableCatalogDef, table_name)) {
        printf ("Error : Table does not exist\n");
        return;
    }

     catalog_table_key.scope = PUBLIC;
     strncpy (catalog_table_key.entity_name,
                  table_name,
                  sizeof (catalog_table_key.entity_name));
     catalog_table_key.type = TABLE;
     strncpy (catalog_table_key.owner, "postgres", sizeof (catalog_table_key.owner));
     bkey.key = (void *)&catalog_table_key;
     bkey.key_size = sizeof (catalog_table_key_t);
     if (BPlusTree_Delete (&TableCatalogDef, &bkey)) {
        printf ("DROP TABLE\n");
     }
}

#if 0
void 
sql_process_delete_query (qep_struct_t *qep) {

    uint32_t count;
    uint32_t inc_count = 0;

    BPluskey_t *bpkey;
    BPluskey_t *bpkey_cpy;
    std::list<BPluskey_t *> key_lst;

    while (qep_execute_join (qep)) {

        bpkey = qep->joined_row_tmplate->key_array[0];
        bpkey_cpy = (BPluskey_t *) calloc (1, sizeof (BPluskey_t));
        bpkey_cpy->key = (void *)calloc (1, bpkey->key_size);
        bpkey_cpy->key_size = bpkey->key_size;
        memcpy (bpkey_cpy->key, bpkey->key, bpkey->key_size);
        key_lst.push_back (bpkey_cpy);
    }

    count = key_lst.size();

    while (!key_lst.empty()) {

        bpkey = key_lst.front();
        key_lst.pop_front();
        if (BPlusTree_Delete (qep->join.tables[0].ctable_val->record_table, bpkey)) {
            inc_count++;
        }
        free(bpkey->key);
        free(bpkey);
    }

    printf ("DELETE %u\n", inc_count);
    if (inc_count != count) {
        printf ("Error : %d rows could not be deleted\n", count - inc_count);
    }
}

#else 

/** generated by Github Copilot
 *  
 * Process a delete query.
 *
 * This function is responsible for processing a delete query represented by the given QEP (Query Execution Plan) structure.
 *
 * @param qep The QEP structure representing the delete query.
 * 
 * This C++ code is part of a function named sql_process_delete_query which is used to process SQL delete queries. The function takes a pointer to a qep_struct_t structure as an argument, which presumably contains information about the query execution plan (QEP).

The function begins by declaring several variables. rc is a boolean that will be used to control the loop later in the function. inc_count is a counter initialized to 0. bpkey and bpkey_cpy are pointers to BPluskey_t structures, which presumably represent keys in a B+ tree, a type of self-balancing search tree often used in databases. key_lst is a list of BPluskey_t pointers.

The function then enters an infinite loop, which will only be broken under certain conditions. Inside this loop, another loop is started with a complex for-loop header. This loop initializes table iterators, sets some flags to false, and calls the qep_execute_join function. The loop continues as long as qep_execute_join returns a truthy value.

Inside this inner loop, the first key from the joined_row_tmplate's key_array is retrieved and a copy of it is created. This copy is then added to the key_lst. If the size of key_lst reaches SQL_MAX_DELETE_ACCUMULATE_COUNT, the inner loop is broken.

After the inner loop, there's a check to see if key_lst is empty. If it is, the outer infinite loop is broken, effectively ending the function's main processing. This suggests that the function continues to process joins and accumulate keys until there are no more keys to process.
 */
void
sql_process_delete_query (qep_struct_t *qep) {

    bool rc;
    uint32_t inc_count = 0;

    BPluskey_t *bpkey;
    BPluskey_t *bpkey_cpy;
    std::list<BPluskey_t *> key_lst;

    while(true) {

        for (table_iterators_init (qep, &qep->titer), 
                qep->is_join_started = false,
                qep->is_join_finished = false,
                rc = qep_execute_join (qep); 
                rc;
                rc = qep_execute_join (qep)) {

            bpkey = qep->joined_row_tmplate->key_array[0];
            bpkey_cpy = (BPluskey_t *) calloc (1, sizeof (BPluskey_t));
            bpkey_cpy->key = (void *)calloc (1, bpkey->key_size);
            bpkey_cpy->key_size = bpkey->key_size;
            memcpy (bpkey_cpy->key, bpkey->key, bpkey->key_size);
            key_lst.push_back (bpkey_cpy);
            if (key_lst.size() == SQL_MAX_DELETE_ACCUMULATE_COUNT ) break;        
        }

        if (key_lst.empty()) break;

        while (!key_lst.empty()) {

            bpkey = key_lst.front();
            key_lst.pop_front();
            if (BPlusTree_Delete (qep->join.tables[0].ctable_val->record_table, bpkey)) {
                inc_count++;
            }
            free(bpkey->key);
            free(bpkey);
        }
    }
    printf ("DELETE %u\n", inc_count);
}
#endif